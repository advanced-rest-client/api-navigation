<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, minimum-scale=1, initial-scale=1, user-scalable=yes">
    <title>api-navigation test</title>
    <script src="../../webcomponentsjs/webcomponents-loader.js"></script>
    <script src="../../web-component-tester/browser.js"></script>
    <link rel="import" href="../api-navigation.html">
    <link rel="import" href="../../arc-polyfills/arc-polyfills.html">
    <link rel="import" href="../../iron-test-helpers/mock-interactions.html">
    <script src="amf-loader.js"></script>
  </head>
  <body>

    <test-fixture id="Basic">
      <template>
        <api-navigation></api-navigation>
      </template>
    </test-fixture>

    <test-fixture id="Summary">
      <template>
        <api-navigation summary></api-navigation>
      </template>
    </test-fixture>

    <test-fixture id="Preselected">
      <template>
        <api-navigation summary selected="test1"></api-navigation>
      </template>
    </test-fixture>

    <script>
      suite('api-navigation', () => {
        suite('Super basics - without model', () => {
          let element;

          suiteSetup((done) => {
            element = fixture('Basic');
            flush(() => done());
          });

          test('summary is not rendered', () => {
            const panel = element.shadowRoot.querySelector('.summary');
            assert.notOk(panel);
          });

          test('documentation is not rendered', () => {
            const panel = element.shadowRoot.querySelector('.documentation');
            assert.notOk(panel);
          });

          test('types is not rendered', () => {
            const panel = element.shadowRoot.querySelector('.types');
            assert.notOk(panel);
          });

          test('security is not rendered', () => {
            const panel = element.shadowRoot.querySelector('.security');
            assert.notOk(panel);
          });

          test('endpoints is not rendered', () => {
            const panel = element.shadowRoot.querySelector('.endpoints');
            assert.notOk(panel);
          });
        });

        suite('Summary', () => {
          let element;
          setup((done) => {
            element = fixture('Summary');
            flush(() => done());
          });

          test('Summary is rendered', () => {
            const panel = element.shadowRoot.querySelector('.summary');
            assert.ok(panel);
          });

          test('Clicking on summary changes selection', () => {
            const node = element.shadowRoot.querySelector('.list-item.summary');
            node.click();
            assert.equal(element.selected, 'summary');
            assert.equal(element.selectedType, 'summary');
          });
        });

        suite('Docs', () => {
          let element;
          let model;
          setup((done) => {
            model = [{
              id: 'test1',
              label: 'test1'
            }, {
              id: 'test2',
              label: 'test2'
            }];
            element = fixture('Preselected');
            element._setDocs(model);
            flush(() => done());
          });

          test('hasDocs is computed', () => {
            assert.isTrue(element.hasDocs);
          });

          test('Docs is rendered', () => {
            const panel = element.shadowRoot.querySelector('.documentation');
            assert.ok(panel);
          });

          test('Preselected has a selection', () => {
            const selector = '.documentation [data-api-id="test1"]';
            const panel = element.shadowRoot.querySelector(selector);
            assert.ok(panel);
          });

          test('Clicking on an item changes selection', () => {
            const node = element.shadowRoot.querySelectorAll('.documentation .list-item')[1];
            node.click();
            assert.equal(element.selected, 'test2');
            assert.equal(element.selectedType, 'documentation');
          });
        });

        suite('Types', () => {
          let element;
          let model;
          setup((done) => {
            model = [{
              id: 'test1',
              label: 'test1'
            }, {
              id: 'test2',
              label: 'test2'
            }];
            element = fixture('Preselected');
            element._setTypes(model);
            flush(() => done());
          });

          test('hasTypes is computed', () => {
            assert.isTrue(element.hasTypes);
          });

          test('Types panel is rendered', () => {
            const panel = element.shadowRoot.querySelector('section.types');
            assert.ok(panel);
          });

          test('Preselected has a selection', () => {
            const selector = '.types [data-api-id="test1"]';
            const panel = element.shadowRoot.querySelector(selector);
            assert.ok(panel);
          });

          test('Clicking on an item changes selection', () => {
            const node = element.shadowRoot.querySelectorAll('.types .list-item')[1];
            node.click();
            assert.equal(element.selected, 'test2');
            assert.equal(element.selectedType, 'type');
          });
        });

        suite('Security', () => {
          let element;
          let model;
          setup((done) => {
            model = [{
              id: 'test1',
              label: 'test1'
            }, {
              id: 'test2',
              label: 'test2'
            }];
            element = fixture('Preselected');
            element._setSecurity(model);
            flush(() => done());
          });

          test('hasSecurity is computed', () => {
            assert.isTrue(element.hasSecurity);
          });

          test('Types panel is rendered', () => {
            const panel = element.shadowRoot.querySelector('section.security');
            assert.ok(panel);
          });

          test('Preselected has a selection', () => {
            const selector = '.security [data-api-id="test1"]';
            const panel = element.shadowRoot.querySelector(selector);
            assert.ok(panel);
          });

          test('Clicking on an item changes selection', () => {
            const node = element.shadowRoot.querySelectorAll('.security .list-item')[1];
            node.click();
            assert.equal(element.selected, 'test2');
            assert.equal(element.selectedType, 'security');
          });
        });

        suite('Endpoints', () => {
          let element;
          let model;
          setup((done) => {
            model = [{
              id: 'test1',
              label: 'test1',
              methods: [{
                id: 'method1',
                method: 'GET'
              }]
            }, {
              id: 'test2',
              label: 'test2',
              methods: [{
                id: 'method2',
                method: 'GET'
              }, {
                id: 'method3',
                method: 'POST'
              }]
            }];
            element = fixture('Preselected');
            element._setEndpoints(model);
            flush(() => done());
          });

          test('hasEndpoints is computed', () => {
            assert.isTrue(element.hasEndpoints);
          });

          test('Types panel is rendered', () => {
            const panel = element.shadowRoot.querySelector('section.endpoints');
            assert.ok(panel);
          });

          test('Preselected has a selection', () => {
            const selector = '.endpoints [data-api-id="test1"]';
            const panel = element.shadowRoot.querySelector(selector);
            assert.ok(panel);
          });

          test('Clicking on endpoint toggles operation', () => {
            const node = element.shadowRoot.querySelectorAll('.endpoints .list-item.endpoint')[1];
            node.click();
            const collapsable = node.nextElementSibling;
            assert.isTrue(collapsable.opened);
          });

          test('Clicking on the overview changes selection', () => {
            const node = element.shadowRoot.querySelectorAll(
              '.list-item.operation[data-shape="endpoint"]')[1];
            node.click();
            assert.equal(element.selected, 'test2');
            assert.equal(element.selectedType, 'endpoint');
          });
        });


        suite('Navigation events`', () => {
          let element;
          let model;
          setup((done) => {
            model = {
              docs: [{
                id: 'test1',
                label: 'test1'
              }, {
                id: 'test2',
                label: 'test2'
              }],
              types: [{
                id: 'test3',
                label: 'test3'
              }, {
                id: 'test4',
                label: 'test4'
              }],
              security: [{
                id: 'test5',
                label: 'test5'
              }, {
                id: 'test6',
                label: 'test6'
              }],
              endpoints: [{
                id: 'test7',
                label: 'test7',
                methods: [{
                  id: 'method8',
                  method: 'GET'
                }]
              }, {
                id: 'test9',
                label: 'test9',
                methods: [{
                  id: 'method10',
                  method: 'GET'
                }, {
                  id: 'method11',
                  method: 'POST'
                }]
              }]
            };
            element = fixture('Basic');
            element._setDocs(model.docs);
            element._setTypes(model.types);
            element._setSecurity(model.security);
            element._setEndpoints(model.endpoints);
            flush(() => done());
          });

          function fire(id, type, node) {
            const e = new CustomEvent('api-navigation-selection-changed', {
              bubbles: true,
              composed: true,
              detail: {
                selected: id,
                type: type
              }
            });
            (node || document.body).dispatchEvent(e);
          }

          test('Updates selection from the change event', () => {
            const id = 'test3';
            fire(id, 'type');
            assert.equal(element.selected, id);
            assert.equal(element.selectedType, 'type');
            const node = element.shadowRoot.querySelector(`[data-api-id="${id}"]`);
            assert.isTrue(node.classList.contains('iron-selected'));
          });

          test('Does not update selection if it is the source', () => {
            const id = 'test3';
            fire(id, 'type', element);
            assert.isUndefined(element.selected);
          });

          test('Does not dispatch selection event', () => {
            const id = 'test3';
            const spy = sinon.spy();
            element.addEventListener('api-navigation-selection-changed', spy);
            fire(id, 'type');
            assert.isFalse(spy.called);
          });

          [
            ['type', 'test3', '.list-item'],
            ['security', 'test5', '.list-item'],
            ['documentation', 'test1', '.list-item'],
            ['endpoint', 'test7', '.operation']
          ].forEach((item) => {
            const [type, id, selector] = item;
            test(`Dispatches event when clicking on ${type}`, function() {
              const s = `${selector}[data-api-id="${id}"]`;
              const node = element.shadowRoot.querySelector(s);
              let called = false;
              element.addEventListener('api-navigation-selection-changed', (e) => {
                called = true;
                assert.equal(e.detail.selected, id);
                assert.equal(e.detail.type, type);
                assert.isUndefined(e.detail.endpointId);
              });
              MockInteractions.tap(node);
              assert.isTrue(called);
            });
          });

          test('Dispatches event when clicking on method', function() {
            const selector = '.operation[data-api-id="method10"]';
            const node = element.shadowRoot.querySelector(selector);
            let called = false;
            element.addEventListener('api-navigation-selection-changed', (e) => {
              called = true;
              assert.equal(e.detail.selected, 'method10');
              assert.equal(e.detail.type, 'method');
              assert.equal(e.detail.endpointId, 'test9');
            });
            MockInteractions.tap(node);
            assert.isTrue(called);
          });
        });
      });
      /* global AmfLoader */
      suite('AMF Computations', () => {
        let element;
        suiteSetup(() => {
          return AmfLoader.load()
          .then((model) => {
            element = fixture('Basic');
            element.amfModel = model;
          });
        });

        test('Collects documentaion information', () => {
          const result = element.docs;
          assert.isAbove(result.length, 0);
          assert.typeOf(result[0].id, 'string');
          assert.typeOf(result[0].label, 'string');
        });

        test('Collects types information', () => {
          const result = element.types;
          assert.isAbove(result.length, 0);
          assert.typeOf(result[0].id, 'string');
          assert.typeOf(result[0].label, 'string');
        });

        test('Collects security information', () => {
          const result = element.security;
          assert.isAbove(result.length, 0);
          assert.typeOf(result[0].id, 'string');
          assert.typeOf(result[0].label, 'string');
        });

        test('Collects endpoints information', () => {
          const result = element.endpoints;
          assert.isAbove(result.length, 0);
          assert.typeOf(result[0].id, 'string');
          assert.typeOf(result[0].label, 'string');
          assert.typeOf(result[0].methods, 'array');
          assert.typeOf(result[0].renderPath, 'boolean');
        });

        test('Collects methods information', () => {
          const result = element.endpoints;
          const methods = result[0].methods;
          assert.isAbove(methods.length, 0);
          assert.typeOf(methods[0].id, 'string');
          assert.typeOf(methods[0].label, 'string');
          assert.typeOf(methods[0].method, 'string');
        });

        test('Collects types from a library', () => {
          const result = element.types;
          assert.lengthOf(result, 10);
          assert.equal(result[9].id, 'amf://id#131');
          assert.equal(result[9].label, 'Type from library');
        });

        test('Types does not include inline declarations', () => {
          const result = element.types;
          for (let i = 0, len = result.length; i < len; i++) {
            assert.equal(result[i].label.indexOf('amf_inline_type'), -1);
          }
        });

        test('renderPath is set on endpoints', () => {
          const result = element.endpoints;
          let endpoint = result[0];
          assert.isTrue(endpoint.renderPath);
          endpoint = result[2];
          assert.isFalse(endpoint.renderPath);
        });

        test('Truncates the path to the last part', () => {
          const result = element.endpoints;
          const endpoint = result[1];
          assert.equal(endpoint.path, '/{fileId}');
        });

        test('Sets missing name as the last part', () => {
          const result = element.endpoints;
          const endpoint = result[2];
          assert.equal(endpoint.label, '/copy');
        });
      });

      suite('Passive selection', () => {
        let element;
        let amf;
        suiteSetup(() => {
          return AmfLoader.load()
          .then((model) => {
            amf = model;
          });
        });

        setup((done) => {
          element = fixture('Basic');
          element.amfModel = amf;
          flush(() => done());
        });

        function dispatch(selected, type) {
          const e = new CustomEvent('api-navigation-selection-changed', {
            bubbles: true,
            composed: true,
            detail: {
              selected,
              type,
              passive: true
            }
          });
          document.body.dispatchEvent(e);
        }

        test('Selectes a method', () => {
          dispatch('amf://id#138', 'method');
          const node = element.shadowRoot.querySelector('.passive-selected');
          assert.ok(node);
        });

        test('Opens iron-collapse', () => {
          dispatch('amf://id#138', 'method');
          const id = 'amf://id#137';
          const node = element.shadowRoot.querySelector(`.endpoint[data-endpoint-id="${id}"]`);
          assert.isTrue(node.nextElementSibling.opened);
        });
      });

      suite('_computeLastPathName()', () => {
        let element;
        suiteSetup(() => {
          element = fixture('Basic');
        });

        test('Computes short path', () => {
          const result = element._computeLastPathName(['a', 'b', 'c']);
          assert.equal(result, '/c');
        });

        test('Computes short path when first item is empty', () => {
          const result = element._computeLastPathName(['', 'b', 'c']);
          assert.equal(result, '/c');
        });
      });

      suite('_computeEndpointPaddingLeft()', () => {
        let element;
        setup((done) => {
          element = fixture('Basic');
          flush(() => done());
        });

        test('Computes default padding', () => {
          const result = element._computeEndpointPaddingLeft();
          assert.equal(result, 16);
        });

        test('Computes value for single value padding', () => {
          element.updateStyles({
            '--api-navigation-list-item-padding': '5px'
          });
          const result = element._computeEndpointPaddingLeft();
          assert.equal(result, 5);
        });

        test('Computes value for double padding value', () => {
          element.updateStyles({
            '--api-navigation-list-item-padding': '5px 10px'
          });
          const result = element._computeEndpointPaddingLeft();
          assert.equal(result, 10);
        });

        test('Computes value for tripple padding value', () => {
          element.updateStyles({
            '--api-navigation-list-item-padding': '5px 10px 15px'
          });
          const result = element._computeEndpointPaddingLeft();
          assert.equal(result, 15);
        });

        test('Computes value for full padding value', () => {
          element.updateStyles({
            '--api-navigation-list-item-padding': '5px 10px 15px 20px'
          });
          const result = element._computeEndpointPaddingLeft();
          assert.equal(result, 15);
        });
      });

      suite('_computeOperationPaddingLeft()', () => {
        let element;
        setup((done) => {
          element = fixture('Basic');
          flush(() => done());
        });

        test('Computes default padding', () => {
          const result = element._computeOperationPaddingLeft();
          assert.equal(result, 24);
        });

        test('Computes padding from css property', () => {
          element.updateStyles({
            '--api-navigation-operation-item-padding-left': '5px'
          });
          const result = element._computeOperationPaddingLeft();
          assert.equal(result, 5);
        });
      });

      a11ySuite('Basic');
    </script>

  </body>
</html>
